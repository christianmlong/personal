# pylint: disable=too-many-lines,too-many-public-methods,line-too-long,missing-docstring
"""
Tests for the sql generation objects of the shopfloor_monitor_data module.

DO NOT EDIT THIS FILE
IT IS AUTOMATICALLY GENERATED
BY write_shopfloor_monitor_data_tests.py



"""

from nose import tools
from nose.plugins.attrib import attr

import pyodbc, sqlparse

from Pickpack.pickpack_modules import pickpack_constants
from Pickpack.pickpack_modules import shopfloor_monitor_data

if pickpack_constants.SHOW_FULL_DIFF:
    # Force Nose to output the full diff
    from unittest import TestCase
    TestCase.maxDiff = None

APLUS_CONNECTION = None

def setup_module():
    """
    Module-level setup code for the tests
    """
    global APLUS_CONNECTION                             # pylint: disable=global-statement
    APLUS_CONNECTION = pyodbc.connect('DSN=Test;UID=NONE;PWD=NONE;') # pylint: disable=no-member

def teardown_module():
    """
    Module-level teardown code for the tests
    """
    APLUS_CONNECTION.close()


class TestShopfloorMonitorDataSQL(object):

    WORKSTATION_DICT = {
        "wcc"       : pickpack_constants.CONSUMABLES_SCALE,
        "parts"     : pickpack_constants.SERVICE_PARTS_SCALE,
        "both"      : pickpack_constants.BOTH_SCALE,
        "all"       : pickpack_constants.ALL_SCALES,
    }

    def __init__(self):
        pass

    def validate(self,
                 data_provider_object,
                 workstation,
                 expected_sql,
                ):
        workstation_code = self.WORKSTATION_DICT[workstation]
        actual_sql = data_provider_object.build_sql(workstation_code)
        actual_sql_tree = sqlparse.parse(actual_sql)[0]
        expected_sql_tree = sqlparse.parse(expected_sql)[0]
        actual_sql_clean = unicode(actual_sql_tree)
        expected_sql_clean = unicode(expected_sql_tree)
        #import pprint
        #print "++++++++++++++++++++++++++++++++++++++++++"
        #print pprint.pformat(actual_sql_clean)
        #print "------------------------------------------"
        #print pprint.pformat(expected_sql_clean)
        #print "++++++++++++++++++++++++++++++++++++++++++"
        tools.assert_equal(actual_sql_clean, expected_sql_clean)

        cur = APLUS_CONNECTION.cursor()
        cur.execute(actual_sql)
        result = cur.fetchall()
        cur.close()

        print
        if result is None:
            print "None"
        elif len(result) == 0:
            print "No rows"
        elif len(result) == 1:
            print "1 row"
            print result[0]
        elif len(result) <= 10:
            print "%s rows" % len(result)
            for row in result:
                print row
        else:
            print "10 rows of %s" % len(result)
            for row in result[:10]:
                print row


    @attr('slow')
    def test_today_sure_ordinary_summary_provider_both(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_summary_provider_wcc(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_summary_provider_parts(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_summary_provider_all(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_detail_data_provider_both(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_detail_data_provider_wcc(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_detail_data_provider_parts(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_ordinary_detail_data_provider_all(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 163000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_ordinary_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_summary_provider_both(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_summary_provider_wcc(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_summary_provider_parts(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_summary_provider_all(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_detail_data_provider_both(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_detail_data_provider_wcc(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_detail_data_provider_parts(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_backorder_detail_data_provider_all(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.today_sure_backorder_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_last_print_data_provider_both(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'



            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.today_sure_last_print_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_last_print_data_provider_wcc(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'



            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.today_sure_last_print_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_last_print_data_provider_parts(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'



            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.today_sure_last_print_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_today_sure_last_print_data_provider_all(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'T'




            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.today_sure_last_print_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_summary_provider_both(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_summary_provider_wcc(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_summary_provider_parts(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_summary_provider_all(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_detail_data_provider_both(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_detail_data_provider_wcc(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_detail_data_provider_parts(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_ordinary_detail_data_provider_all(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

                and oh.ohettm > 130000

                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_ordinary_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_summary_provider_both(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_summary_provider_wcc(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_summary_provider_parts(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_summary_provider_all(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_detail_data_provider_both(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_detail_data_provider_wcc(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_detail_data_provider_parts(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_backorder_detail_data_provider_all(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.signature_service_backorder_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_last_print_data_provider_both(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'



            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.signature_service_last_print_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_last_print_data_provider_wcc(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'



            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.signature_service_last_print_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_last_print_data_provider_parts(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'



            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.signature_service_last_print_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_signature_service_last_print_data_provider_all(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'SS'




            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.signature_service_last_print_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_summary_provider_both(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_summary_provider_wcc(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_summary_provider_parts(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_summary_provider_all(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_detail_data_provider_both(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_detail_data_provider_wcc(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_detail_data_provider_parts(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_ordinary_detail_data_provider_all(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_ordinary_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_summary_provider_both(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_summary_provider_wcc(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_summary_provider_parts(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_summary_provider_all(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_detail_data_provider_both(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_detail_data_provider_wcc(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_detail_data_provider_parts(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_backorder_detail_data_provider_all(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.service_files_backorder_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_last_print_data_provider_both(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'



            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.service_files_last_print_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_last_print_data_provider_wcc(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'



            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.service_files_last_print_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_last_print_data_provider_parts(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'



            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.service_files_last_print_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_service_files_last_print_data_provider_all(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'S'




            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.service_files_last_print_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_summary_provider_both(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_summary_provider_wcc(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_summary_provider_parts(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_summary_provider_all(self):
        expected_sql = """
        select before_cutoff,
order_status,
count(*)
        from (
            select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by before_cutoff, order_status
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_detail_data_provider_both(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_detail_data_provider_wcc(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_detail_data_provider_parts(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_ordinary_detail_data_provider_all(self):
        expected_sql = """
        select
                case
                when oh.ohetdt >= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))



                then 'N'    -- After cutoff
                else 'Y'    -- Before cutoff
                end
             before_cutoff,

            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn = 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by before_cutoff, order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_ordinary_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_summary_provider_both(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.normal_backorder_summary_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_summary_provider_wcc(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.normal_backorder_summary_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_summary_provider_parts(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.normal_backorder_summary_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_summary_provider_all(self):
        expected_sql = """
        select order_status,
count(*)
        from (
            select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        ) as temp
        group by order_status
    """
        self.validate(shopfloor_monitor_data.normal_backorder_summary_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_detail_data_provider_both(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0

            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_backorder_detail_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_detail_data_provider_wcc(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0

            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_backorder_detail_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_detail_data_provider_parts(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0

            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_backorder_detail_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_backorder_detail_data_provider_all(self):
        expected_sql = """
        select
            case

            when oh.ohorst = '1'
            then 20

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) = ''
            then 21

            when oh.ohorst = '2'
            and trim(coalesce(oh.ohpacc, '')) != ''
            then 22

            else 23

            end
         order_status,
trim(oh.ohorno) || '/' || right('00' || trim(char(oh.ohorgn)), 2) formatted_order_number

            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'

            and oh.ohorgn > 0


            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'


        order by order_status, formatted_order_number
    """
        self.validate(shopfloor_monitor_data.normal_backorder_detail_data_provider,
                      'all',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_last_print_data_provider_both(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'



            and temp3.which_scale = 'B'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.normal_last_print_data_provider,
                      'both',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_last_print_data_provider_wcc(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'



            and temp3.which_scale = 'C'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.normal_last_print_data_provider,
                      'wcc',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_last_print_data_provider_parts(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh


            -- Here we're joning from our main query to a temp table that holds
            -- business unit data. We use a temp table rather than a correlated
            -- subselect. A correlated subselect has to run the subquery for
            -- each row in the outer query, and we don't want that.
            join
            (
                -- This is the outer "group by". It takes all the busiess units for each order, and
                -- decides which scale should handle that order.
                select order_number
                     , order_generation
                     -- Here we're aggregating all the order's conceptual business units
                     -- (C, H, S) in to a concatenated string (e.g. C, S, HS, CHS). Then
                     -- we're mapping the aggregated conceptual business units to the
                     -- scales that handle them.
                     , case xmlserialize(xmlagg(xmltext(conceptual_business_unit) order by conceptual_business_unit) as varchar(100))
                       when 'C'     -- Only Consumables items: Consumables scale
                       then 'C'
                       when 'H'     -- Only helmets: Consumables scale
                       then 'C'
                       when 'S'     -- Only Service Parts items: Service Parts scale
                       then 'S'
                       when 'CH'    -- Consumables items and helmets: Consumables scale
                       then 'C'
                       when 'CS'    -- Consumables items and Service Parts items: Both scale
                       then 'B'
                       when 'HS'    -- Helmets and Service Parts items: Both scale
                       then 'B'
                       when 'CHS'   -- Consumables items, helmets and Service Parts items: Both scale
                       then 'B'
                       --else null
                       else 'C'     -- Any weird cases get grouped in with Consumables.
                       end which_scale
                from
                (
                    -- This is the inner "group by". It takes all the items on each order, and
                    -- groups them by business unit. The result is a series of rows for each order,
                    -- with each row representing a business unit whose items are on that order.
                    --
                    -- For example:
                    -- 6P626  0   C
                    -- 6P626  0   H
                    -- 6P626  0   S
                    -- 6P627  0   C
                    -- 6P627  0   S
                    -- 6P628  0   C
                    -- 6P629  0   C
                    --
                    -- Also, we use a sub-select here, to allow us to say "group by conceptual_business_unit"
                    -- instead of "group by case trim(im.imvnno) when 'B04' then 'C' . . . "
                    select order_number
                         , order_generation
                         , conceptual_business_unit
                    from
                    (
                        -- Select all the items on all the open orders
                        select oh2.ohorno                order_number
                             , oh2.ohorgn                order_generation
                             -- Here we're reducing APlus business units (B##) to one letter
                             -- abbreviations corresponding to conceptual business units:
                             -- C - Consumables, H - Helmets, S - Service Parts.
                             , case trim(im.imvnno)
                               when 'B04' then 'C'
                               when 'B13' then 'C'
                               when 'B15' then 'S'
                               when 'B35' then 'C'
                               when 'B38' then 'H'
                               else 'C'                 -- Treat unknown BUs as Consumables
                               end                      conceptual_business_unit
                        from orhed oh2
                        join ordet od
                        on oh2.ohcono = od.odcono
                        and oh2.ohorno = od.odorno
                        and oh2.ohorgn = od.odorgn
                        join itmst im
                        on od.oditno = im.imitno
                        where oh2.ohwhid = 'PW'        -- Warehouse ID
                        and oh2.ohcono = 1             -- Company Number
                        and oh2.ohortp = 'O'           -- Order Type - O is an order
                        and oh2.ohorst in ('1', '2')   -- Order Status Code
                        and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                        and od.odqtsh > 0              -- Quantity shipped
                    ) as temp1
                    group by order_number
                           , order_generation
                           , conceptual_business_unit
                ) as temp2
                group by order_number
                       , order_generation
                order by order_number desc
                       , order_generation
            ) as temp3
            on oh.ohorno = temp3.order_number
            and oh.ohorgn = temp3.order_generation


            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'



            and temp3.which_scale = 'S'


            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.normal_last_print_data_provider,
                      'parts',
                      expected_sql,
                      )


    @attr('slow')
    def test_normal_last_print_data_provider_all(self):
        expected_sql = """
        -- Our dates in APlus are stored as integers. O_o
        --
        -- Parsing them out is cumbersome
        select  trim(temp1.order_number) || '/' || right('00' || trim(char(temp1.order_generation)), 2)
             ,  trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.order_entry_date_as_int_string, 1, 4 )) order_entry_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.order_entry_time_as_int_string, 1, 2 ) ||      -- Two hour characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 3, 2 ) ||      -- Two minute characters
                    ':' ||                                                      -- ISO standard time separator
                    substr(temp1.order_entry_time_as_int_string, 5, 2 )         -- Two second characters
                ), USA)) order_entry_time_as_string
             ,  trim(leading '0' from substr(temp1.last_print_date_as_int_string, 5, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 7, 2 )) ||
                '/' ||
                trim(leading '0' from substr(temp1.last_print_date_as_int_string, 1, 4 )) last_print_date_as_string
                -- Round-trip through the DB2 time format, to make sure it
                -- is formatted consistently (AM, PM, etc.)
             ,  trim(leading '0' from char(time(
                    substr(temp1.last_print_time_as_int_string, 1, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 3, 2 ) ||
                    ':' ||
                    substr(temp1.last_print_time_as_int_string, 5, 2 )
                ), USA)) last_print_time_as_string
        from (
            select  trim(char(oh.ohetcc)) ||                        -- Two century digits
                    right(                                          -- Left-zero-pad the string, to allow for single-digit years
                        repeat('0', 6) || trim(char(oh.ohetdt)),
                        6
                    ) order_entry_date_as_int_string
                 ,  right(                                          -- Left-zero-pad the string, to allow for single-digit hours
                        repeat('0', 6) || trim(char(oh.ohettm)),
                        6
                    ) order_entry_time_as_int_string
                 ,  trim(char(oh.ohppcc)) ||
                    right(
                        repeat('0', 6) || trim(char(oh.ohppdt)),
                        6
                    ) last_print_date_as_int_string
                 ,  right(
                        repeat('0', 6) || trim(char(oh.ohpptm)),
                        6
                    ) last_print_time_as_int_string
                 ,  oh.ohorno       order_number
                 ,  oh.ohorgn       order_generation


            from orhed oh



            where oh.ohorst in ('1', '2')   -- Status: ready or printed
            and oh.ohwhid = 'PW'            -- Parts Warehouse
            and oh.ohcono = 1               -- Company Number 1
            and oh.ohortp = 'O'             -- Order Type
            -- Some orders have requested ship date in the future: exclude them.
            -- Only return orders that have requested ship date of today or earlier.
            and oh.ohrsdt <= int(varchar_format(CURRENT_TIMESTAMP, 'YYMMDD'))

            and trim(substr(oh.ohus15, 8, 2)) = 'N'




            -- Exclude orders that have no detail lines.
            and exists
            (
                select 1
                from ordet od
                where oh.ohcono = od.odcono
                and oh.ohorno = od.odorno
                and oh.ohorgn = od.odorgn
                and od.odlitp = 'I'            -- Line Item Type - I is an item, M is a comment
                and od.odqtsh > 0              -- Quantity shipped
            )



            and oh.ohfl01 != 'T'



            and oh.ohppdt > 0
            and oh.ohpptm > 0
            -- Only get the most-recently printed order
            order by oh.ohppdt desc
                   , oh.ohpptm desc
            fetch first row only
        ) as temp1
    """
        self.validate(shopfloor_monitor_data.normal_last_print_data_provider,
                      'all',
                      expected_sql,
                      )
